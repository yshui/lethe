vertex ballv(
	vec2 position,
	vec2 translate,
	vec2 texture_coord,
	float angle,
	float alpha
);
vertex hitball(
	float r,
	vec2 center
);
vertex hittri (
	vec2 p1, vec2 p2, vec2 p3
);
event Collide(particle);
event nextFrame(float);
particle Wall {
	vec2 start;
	vec2 end;
	state Update @ nextFrame {
		hitboxes << `hittri(start, end, (start+end)/2.0);
		nextState = Update;
	};
}
particle WallN << Wall{
	>(float w) {
		start <- vec2(0, 10);
		end <- vec2(w, 10);
		`Update;
	}
}
particle WallS << Wall{
	>(float w, float h) {
		start <- vec2(0, h-10.0);
		end <- vec2(w, h-10.0);
		`Update;
	}
}
particle WallW << Wall{
	>(float h) {
		start <- vec2(10, 0);
		end <- vec2(10, h);
		`Update;
	}
}
particle WallE << Wall{
	>(float w, float h) {
		start <- vec2(w-10.0, 0);
		end <- vec2(w-10.0, h);
		`Update;
	}
}
particle Spark {
	vec2 center;
	float r;
	vec2 velocity;
	float alpha;
	>(center) {
		r <- 5.0;
		velocity <- $(vec2(-1, -1)..vec2(1, 1))*2;
		alpha<- 1.0;
		`Decay;
	}
	state Decay @ nextFrame {
		center <- center+velocity;
		r <- r*0.9;
		alpha <- alpha*0.9;
		render << `ballv(vec2(-1, 1)*r, center, vec2(-1, 1), 0, alpha),
			  `ballv(vec2(-1, -1)*r, center, vec2(-1, -1), 0, alpha),
			  `ballv(vec2(1, -1)*r, center, vec2(1, -1), 0, alpha),
			  `ballv(vec2(1, 1)*r, center, vec2(1, 1), 0, alpha);
		render << -4, -3, -2, -4, -2, -1;
		if (r < 1e-6)
			nextState = Deleted;
		else
			nextState = Decay;
	};
}
particle Ball {
	vec2 center;
	vec2 velocity;
	float r;
	state Update @ nextFrame {
		center <- center+velocity;
		render << `ballv(vec2(-1, 1)*r, center, vec2(-1, 1), 0,1),
			  `ballv(vec2(-1, -1)*r, center, vec2(-1, -1), 0,1),
			  `ballv(vec2(1, -1)*r, center, vec2(1, -1), 0,1),
			  `ballv(vec2(1, 1)*r, center, vec2(1, 1), 0,1);
		render << -4, -3, -2, -4, -2, -1;
		hitboxes << `hitball(r, center);
		nextState = Update;
	};
	state Move @ Collide(Ball(x)) {
		line = x.center - center;
		dist = line *: line;
		vm = line *. velocity / dist;
		vo = line *. x.velocity / dist;
		if (vo-vm <= 0.0) {
			tmpv = velocity-vm*line/dist;
			velocity <- tmpv+vo*line/dist;
			poc = center+line/2.0;
			loop(0..5)
				`Spark(poc);
		}
		nextState = Move;
	},
	@ Collide(WallN(x)) {
		if (velocity.y < 0.0)
			velocity <- vec2(velocity.x, -velocity.y);
		nextState = Move;
	},
	@ Collide(WallS(x)) {
		if (velocity.y > 0.0)
			velocity <- vec2(velocity.x, -velocity.y);
		nextState = Move;
	},
	@ Collide(WallW(x)) {
		if (velocity.x < 0.0)
			velocity <- vec2(-velocity.x, velocity.y);
		nextState = Move;
	},
	@ Collide(WallE(x)) {
		if (velocity.x > 0.0)
			velocity <- vec2(-velocity.x, velocity.y);
		nextState = Move;
	};
	>(center, velocity, r) {
		`Update;
		`Move;
	}
}
particle Bootstrap {
	>(float w, float h) {
		loop(i~0..150)
			`Ball($(vec2(10, 10)..vec2(w, h)),
			      $(vec2(-1, -1)..vec2(1, 1)),
			      $(2..5));
		`WallN(w);
		`WallW(h);
		`WallE(w, h);
		`WallS(w, h);
	}
}
